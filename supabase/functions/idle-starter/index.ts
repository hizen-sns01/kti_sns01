import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders } from '../_shared/cors.ts';

// Generates a conversation starter using the Gemini API.
// The user must set GEMINI_API_KEY in their Supabase project secrets.
async function getIdleTopic(context: string): Promise<string> {
  console.log(`Generating idle topic for context: ${context}`);

  const apiKey = Deno.env.get('GEMINI_API_KEY');
  if (!apiKey) {
    console.error("GEMINI_API_KEY is not set in environment variables.");
    // Return a generic fallback question if the key is missing
    return `Let's talk about ${context}. What's something interesting you've learned recently?`;
  }

  const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${apiKey}`;
  
  const prompt = `You are an AI curator in a chatroom. Your goal is to spark conversation in a room that has gone quiet. The topic of the chatroom is "${context}". Generate one single, engaging, open-ended question to get people talking again. Keep it friendly and concise.`;

  const requestBody = {
    contents: [{ parts: [{ text: prompt }] }],
    // Optional: Add safety settings and generation config if needed
    // safetySettings: [...],
    // generationConfig: { temperature: 0.7, maxOutputTokens: 100 },
  };

  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error(`Gemini API error: ${response.status}`, errorData);
      throw new Error('Gemini API request failed');
    }

    const data = await response.json();
    const aiGeneratedQuestion = data?.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!aiGeneratedQuestion) {
      throw new Error("No content generated by AI.");
    }

    return aiGeneratedQuestion.trim();

  } catch (error) {
    console.error('Error calling Gemini API for idle topic:', error);
    // Return a generic fallback question on API error
    return `Let's pick things up. What's everyone's favorite thing about ${context}?`;
  }
}

Deno.serve(async (req) => {
  // This is needed if you're invoking the function via a browser.
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Create a Supabase client with the appropriate credentials
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      { global: { headers: { Authorization: `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}` } } }
    );

    const aiUserId = '4bb3e1a3-099b-4b6c-bf3a-8b60c51baa79';
    const DEFAULT_IDLE_THRESHOLD_MINUTES = 240; // 4 hours

    // 1. Fetch ALL chatrooms to check their individual thresholds
    const { data: allChatrooms, error: chatroomsError } = await supabaseClient
      .from('chatrooms')
      .select('id, interest, last_message_at, idle_threshold_minutes');

    if (chatroomsError) {
      throw new Error(`Failed to fetch chatrooms: ${chatroomsError.message}`);
    }

    if (!allChatrooms || allChatrooms.length === 0) {
      return new Response(JSON.stringify({ message: 'No chatrooms found.' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    const now = new Date();
    const idleRoomsToProcess = allChatrooms.filter(room => {
      const thresholdMinutes = room.idle_threshold_minutes || DEFAULT_IDLE_THRESHOLD_MINUTES;
      const thresholdTime = new Date(now.getTime() - thresholdMinutes * 60 * 1000);
      return new Date(room.last_message_at) < thresholdTime;
    });

    if (idleRoomsToProcess.length === 0) {
      console.log('No idle chatrooms to process.');
      return new Response(JSON.stringify({ message: 'No idle chatrooms to process.' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    console.log(`Found ${idleRoomsToProcess.length} idle chatrooms.`);

    // 2. For each idle chatroom, generate a topic and insert a message
    const promises = idleRoomsToProcess.map(async (room) => {
      const topicContext = room.interest || 'general discussion';
      const newTopic = await getIdleTopic(topicContext);

      const { error: insertError } = await supabaseClient.from('messages').insert({
        chatroom_id: room.id,
        user_id: aiUserId,
        content: newTopic,
        is_ai_curator: true,
      });

      if (insertError) {
        console.error(`Failed to insert message for room ${room.id}:`, insertError);
      }
    });

    await Promise.all(promises);

    return new Response(JSON.stringify({ message: `Processed ${idleRoomsToProcess.length} idle chatrooms.` }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('Error in idle-starter handler:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
});