import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders } from '../_shared/cors.ts';

// Summarizes chat messages using the Gemini API.
// The user must set GEMINI_API_KEY in their Supabase project secrets.
async function getChatSummary(chatroomId: string, chatMessages: string, persona?: string): Promise<string> {
  console.log(`Generating chat summary for chatroom: ${chatroomId}`);

  const apiKey = Deno.env.get('GEMINI_API_KEY');
  if (!apiKey) {
    console.error("GEMINI_API_KEY is not set in environment variables.");
    return "채팅 요약을 생성할 수 없습니다. API 키가 설정되지 않았습니다.";
  }

  const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${apiKey}`;
  
  let prompt = `다음 채팅 대화를 3줄 이내로 요약해 주세요. 중요한 키워드는 **굵게** 표시하고, 마크다운 형식으로 작성해 주세요.`;

  if (persona) {
    prompt += `\n\n당신은 다음 페르소나를 가지고 요약합니다: ${persona}`;
  }

  prompt += `\n---\n채팅 대화:\n${chatMessages}`;

  const requestBody = {
    contents: [{ parts: [{ text: prompt }] }],
  };

  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error(`Gemini API error: ${response.status}`, errorData);
      throw new Error('Gemini API request failed');
    }

    const data = await response.json();
    const aiGeneratedContent = data?.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!aiGeneratedContent) {
      throw new Error("No content generated by AI.");
    }

    return aiGeneratedContent.trim();

  } catch (error) {
    console.error('Error calling Gemini API for chat summary:', error);
    return "채팅 요약을 생성하는 중 오류가 발생했습니다.";
  }
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      { global: { headers: { Authorization: `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}` } } }
    );

    const aiUserId = '4bb3e1a3-099b-4b6c-bf3a-8b60c51baa79'; // Replace with your actual AI user ID

    // Fetch all chatrooms
    const { data: chatrooms, error: chatroomsError } = await supabaseClient
      .from('chatrooms')
      .select('id, interest, persona')
      .eq('enable_article_summary', true);

    if (chatroomsError) {
      throw new Error(`Failed to fetch chatrooms: ${chatroomsError.message}`);
    }

    if (!chatrooms || chatrooms.length === 0) {
      return new Response(JSON.stringify({ message: 'No chatrooms found.' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    const now = new Date();
    const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000); // 24 hours ago

    const promises = chatrooms.map(async (room) => {
      // Fetch messages from the last 24 hours for each chatroom
      const { data: messages, error: messagesError } = await supabaseClient
        .from('messages')
        .select('content')
        .eq('chatroom_id', room.id)
        .gte('created_at', twentyFourHoursAgo.toISOString())
        .neq('is_ai_curator', true)
        .order('created_at', { ascending: true });

      if (messagesError) {
        console.error(`Failed to fetch messages for chatroom ${room.id}: ${messagesError.message}`);
        return;
      }

      if (!messages || messages.length === 0) {
        console.log(`No messages in the last 24 hours for chatroom ${room.id}.`);
        return;
      }

      const concatenatedMessages = messages.map(msg => msg.content).join('\n');
      const summary = await getChatSummary(room.id, concatenatedMessages, room.persona);

      // Insert the summary into the messages table
      const { error: insertError } = await supabaseClient.from('messages').insert({
        chatroom_id: room.id,
        user_id: aiUserId,
        content: summary,
        is_ai_curator: true,
        curator_message_type: 'SUMMARY',
      });

      if (insertError) {
        console.error(`Failed to insert summary for chatroom ${room.id}:`, insertError);
      } else {
        console.log(`Successfully inserted summary for chatroom ${room.id}.`);
      }
    });

    await Promise.all(promises);

    return new Response(JSON.stringify({ message: `Processed ${chatrooms.length} chatrooms for summary.` }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('Error in chat-summary handler:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
});
