-- =================================================================
-- FINAL SCHEMA SCRIPT (v2)
-- This single script contains everything needed for the database.
-- Run this entire script in a new, blank SQL query editor.
-- =================================================================

-- 1. Profiles Table and Auth Trigger

-- Create the profiles table
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email text,
    nickname text UNIQUE,
    interests text[],
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Auth Trigger: Create a profile entry when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, email)
  VALUES (new.id, new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 2. Chat-related Tables

CREATE TABLE IF NOT EXISTS public.chatrooms (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    name text NOT NULL,
    description text,
    interest text UNIQUE,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    last_message_at timestamp with time zone DEFAULT now() NOT NULL, -- Added for AI Curator
    persona text, -- Added for Curator Persona
    idle_threshold_minutes integer, -- Added for Idle Time Detection
    enable_article_summary boolean DEFAULT false -- Added for Article Summary Toggle
);

CREATE TABLE IF NOT EXISTS public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    chatroom_id uuid REFERENCES public.chatrooms(id) NOT NULL,
    user_id uuid REFERENCES auth.users(id) NOT NULL,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    is_ai_curator boolean DEFAULT false NOT NULL, -- Added for AI Curator
    curator_message_type text, -- Added for Curator Message Type
    is_deleted boolean DEFAULT false NOT NULL, -- Added for soft delete
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL, -- Added for soft delete
    like_count integer DEFAULT 0 NOT NULL -- Added for like feature
);

CREATE TABLE IF NOT EXISTS public.participants (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    chatroom_id uuid REFERENCES public.chatrooms(id) NOT NULL,
    user_id uuid REFERENCES auth.users(id) NOT NULL,
    last_read_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(chatroom_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.feeds (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    chatroom_id uuid REFERENCES public.chatrooms(id) ON DELETE CASCADE,
    title text NOT NULL,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Function to update last_message_at in chatrooms table (for AI Curator)
CREATE OR REPLACE FUNCTION public.update_last_message_at()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.chatrooms
  SET last_message_at = now()
  WHERE id = NEW.chatroom_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to execute the function after a new message is inserted (for AI Curator)
DROP TRIGGER IF EXISTS on_new_message ON public.messages;
CREATE TRIGGER on_new_message
  AFTER INSERT ON public.messages
  FOR EACH ROW
  EXECUTE PROCEDURE public.update_last_message_at();


-- 3. Seed data for chatrooms
INSERT INTO public.chatrooms (name, description, interest) VALUES
('React', 'React, Next.js, and all things frontend.', 'Frontend'),
('Node.js', 'Discussing Node.js, Express, and backend development.', 'Backend'),
('Python', 'Everything about Python, from web dev to data science.', 'Python'),
('DevOps', 'CI/CD, Docker, Kubernetes, and more.', 'DevOps')
ON CONFLICT (interest) DO NOTHING;


-- 4. Row Level Security (RLS) Policies

-- First, drop all dependent policies
DROP POLICY IF EXISTS "Users can view messages in chatrooms they are in" ON public.messages;
DROP POLICY IF EXISTS "Users can insert messages in chatrooms they are in" ON public.messages;
DROP POLICY IF EXISTS "Users can view participants in chatrooms they are in" ON public.participants;

-- Then, drop the function
DROP FUNCTION IF EXISTS public.is_participant(uuid) CASCADE;

-- Now, create the function
CREATE OR REPLACE FUNCTION public.is_participant(p_chatroom_id uuid)
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.participants
    WHERE chatroom_id = p_chatroom_id AND user_id = auth.uid()
  );
END;
$$;

-- Finally, create all policies

-- Profiles Policies
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Authenticated users can view all profiles" ON public.profiles;
CREATE POLICY "Authenticated users can view all profiles" ON public.profiles FOR SELECT TO authenticated USING (true);

-- Chatrooms Policies
ALTER TABLE public.chatrooms ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Authenticated users can view all chatrooms" ON public.chatrooms;
CREATE POLICY "Authenticated users can view all chatrooms" ON public.chatrooms FOR SELECT TO authenticated USING (true);

-- Messages Policies
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view messages in chatrooms they are in" ON public.messages FOR SELECT USING ( public.is_participant(chatroom_id) );
CREATE POLICY "Users can insert messages in chatrooms they are in" ON public.messages FOR INSERT WITH CHECK ( public.is_participant(chatroom_id) );
CREATE POLICY "Users can update their own messages" ON public.messages FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Participants Policies
ALTER TABLE public.participants ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view participants in chatrooms they are in" ON public.participants FOR SELECT USING ( public.is_participant(chatroom_id) );

DROP POLICY IF EXISTS "Users can update their own participation record" ON public.participants;
CREATE POLICY "Users can update their own participation record" ON public.participants FOR UPDATE USING ( user_id = auth.uid() ) WITH CHECK ( user_id = auth.uid() );

-- Feeds Policies
ALTER TABLE public.feeds ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Authenticated users can view feeds" ON public.feeds;
CREATE POLICY "Authenticated users can view feeds" ON public.feeds FOR SELECT TO authenticated USING (true);

-- Like Tables
CREATE TABLE IF NOT EXISTS public.message_likes (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    message_id bigint REFERENCES public.messages(id) ON DELETE CASCADE NOT NULL,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE (message_id, user_id)
);

-- Message Likes Policies
ALTER TABLE public.message_likes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all likes" ON public.message_likes FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can insert their own likes" ON public.message_likes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own likes" ON public.message_likes FOR DELETE USING (auth.uid() = user_id);



-- 5. Realtime (Optional, run separately if needed)
-- ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;

CREATE TABLE post_likes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID REFERENCES feeds(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(post_id, user_id)
);

CREATE TABLE post_dislikes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID REFERENCES feeds(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(post_id, user_id)
);

CREATE TABLE post_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID REFERENCES feeds(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE message_dislikes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id BIGINT REFERENCES messages(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(message_id, user_id)
);

CREATE TABLE message_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id BIGINT REFERENCES messages(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- RLS Policies for new tables

ALTER TABLE public.post_likes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all likes" ON public.post_likes FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can insert their own likes" ON public.post_likes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own likes" ON public.post_likes FOR DELETE USING (auth.uid() = user_id);

ALTER TABLE public.post_dislikes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all dislikes" ON public.post_dislikes FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can insert their own dislikes" ON public.post_dislikes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own dislikes" ON public.post_dislikes FOR DELETE USING (auth.uid() = user_id);

ALTER TABLE public.post_comments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all comments" ON public.post_comments FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can insert their own comments" ON public.post_comments FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own comments" ON public.post_comments FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own comments" ON public.post_comments FOR DELETE USING (auth.uid() = user_id);

ALTER TABLE public.message_dislikes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all dislikes" ON public.message_dislikes FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can insert their own dislikes" ON public.message_dislikes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own dislikes" ON public.message_dislikes FOR DELETE USING (auth.uid() = user_id);

ALTER TABLE public.message_comments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all comments" ON public.message_comments FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can insert their own comments" ON public.message_comments FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own comments" ON public.message_comments FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own comments" ON public.message_comments FOR DELETE USING (auth.uid() = user_id);
